# Shiny app for miRNA qPCR analysis with Fold Change and ROC curves
# Fixed overfitting issue in combined ROC using regularization

library(shiny)
library(readxl)
library(dplyr)
library(ggplot2)
library(stringr)
library(pROC)
library(tidyr)
library(glmnet)  # For regularized logistic regression

ui <- fluidPage(
  titlePanel("miRNA qPCR Analysis - Fold Change"),
  sidebarLayout(
    sidebarPanel(
      fileInput("file", "Upload Excel File", accept = c(".xlsx")),
      helpText("Excel file must have columns: Well, Fluor, Target, Sample, Cq, Cq Mean, Type, Sd"),
      uiOutput("targetSelector"),
      uiOutput("barTargetSelector"),
      helpText("Bar plot shows average of all Normal miRNAs (1 bar) and Tumor averages per miRNA."),
      numericInput("cvFolds", "Cross-validation folds:", value = 5, min = 3, max = 10, step = 1),
      helpText("More folds reduce overfitting but increase computation time.")
    ),
    mainPanel(
      tabsetPanel(
        tabPanel("Dot Plots", uiOutput("dotPlotsUI")),
        tabPanel("Bar Plot", plotOutput("barPlot", height = 400)),
        tabPanel("Table (per-miRNA means)", tableOutput("summaryTable")),
        tabPanel("ROC Curves", 
                 plotOutput("allROCPlots", height = 600),
                 plotOutput("combinedROCPlot", height = 400),
                 verbatimTextOutput("modelSummary"))
      )
    )
  )
)

server <- function(input, output) {

  rawData <- reactive({
    req(input$file)
    df <- read_excel(input$file$datapath)
    names(df) <- make.names(names(df))  # clean column names
    df <- df %>% filter(!is.na(Cq.Mean), !is.na(Target), !is.na(Type)) %>%
      filter(!str_detect(Type, regex("^NTC$", ignore_case = TRUE)))
    return(df)
  })

  foldChangeData <- reactive({
    df <- rawData()
    df <- df %>% filter(Type %in% c("Normal", "Tumor"))

    normalizer <- df %>%
      filter(Target %in% c("U6","UniSP6")) %>%
      group_by(Sample) %>%
      summarise(normalizer_Cq = mean(Cq.Mean, na.rm = TRUE), .groups="drop")

    delta_cq <- df %>%
      filter(!Target %in% c("U6","UniSP6")) %>%
      left_join(normalizer, by="Sample") %>%
      mutate(delta_Cq = Cq.Mean - normalizer_Cq)

    normal_avg <- delta_cq %>%
      filter(Type=="Normal") %>%
      group_by(Target) %>%
      summarise(avg_normal_delta_Cq = mean(delta_Cq, na.rm=TRUE), .groups="drop")

    fold_change_df <- delta_cq %>%
      left_join(normal_avg, by="Target") %>%
      mutate(delta_delta_Cq = delta_Cq - avg_normal_delta_Cq,
             fold_change = 2^(-delta_delta_Cq))
    return(fold_change_df)
  })

  perMiRNAMeans <- reactive({
    foldChangeData() %>%
      group_by(Target, Type) %>%
      summarise(mean_fold_change = mean(fold_change, na.rm=TRUE),
                sd_fold_change   = sd(fold_change, na.rm=TRUE),
                n = n(),
                .groups="drop")
  })

  output$targetSelector <- renderUI({
    targets <- unique(foldChangeData()$Target)
    checkboxGroupInput("selectedTargets", "Select miRNAs for dot plots:",
                       choices = targets, selected = targets)
  })

  output$barTargetSelector <- renderUI({
    targets <- unique(foldChangeData()$Target)
    checkboxGroupInput("selectedBarTargets", "Select miRNAs included in bar plot:",
                       choices = targets, selected = targets)
  })

  output$dotPlotsUI <- renderUI({
    req(input$selectedTargets)
    plotOutput("allDotPlots", height = 400 + 120*ceiling(length(input$selectedTargets)/3))
  })

  output$allDotPlots <- renderPlot({
    df <- foldChangeData()
    req(input$selectedTargets)
    df_subset <- df %>% filter(Target %in% input$selectedTargets)
    ggplot(df_subset, aes(x = Type, y = fold_change, color = Type)) +
    geom_boxplot()+
      geom_jitter(position = position_jitterdodge(jitter.width=0.1,dodge.width=0.5),
                  size=2.5, alpha=0.7) +
      stat_summary(fun=mean, geom="point", shape=18, size=4, color="black",
                   position=position_dodge(width=0.5)) +
      scale_color_manual(values=c("Normal"="grey40","Tumor"="darkred")) +
      scale_y_log10() +
      labs(y="Fold Change (log scale)", x="") +
      facet_wrap(~Target, scales="free_x", ncol=3) +
      theme_classic() +
      theme(legend.position="none",
            strip.text=element_text(size=12,face="bold"),
            axis.text.x=element_text(size=10))
  })

  output$barPlot <- renderPlot({
    req(input$selectedBarTargets)
    pm <- perMiRNAMeans() %>% filter(Target %in% input$selectedBarTargets)
    norm_bar <- pm %>% filter(Type=="Normal") %>% summarise(mean_fold=mean(mean_fold_change, na.rm=TRUE))
    norm_bar <- tibble(Label="Normal", mean_fold=norm_bar$mean_fold, Group="Normal")
    tumor_bars <- pm %>% filter(Type=="Tumor") %>% transmute(Label=Target, mean_fold=mean_fold_change, Group="Tumor")
    bar_data <- bind_rows(norm_bar, tumor_bars)
    bar_data$Label <- factor(bar_data$Label, levels=rev(bar_data$Label))
    ggplot(bar_data, aes(y=Label, x=mean_fold, fill=Group)) +
      geom_col(width=0.6) +
      geom_vline(xintercept=1, linetype="dashed", color="gray40") +
      scale_fill_manual(values=c("Normal"="grey40","Tumor"="darkred")) +
      labs(title="Fold Change: Overall Normal vs Tumor per miRNA",
           x="Fold Change (log scale)", y="") +
      scale_x_log10() +
      theme_minimal() +
      theme(axis.text.x=element_text(angle=0, hjust=0.5))
  })

  output$summaryTable <- renderTable({
    perMiRNAMeans() %>% arrange(Target, match(Type,c("Normal","Tumor")))
  })

  output$allROCPlots <- renderPlot({
    req(input$selectedTargets)
    df <- foldChangeData()
    
    n_plots <- length(input$selectedTargets)
    n_cols <- 3
    n_rows <- ceiling(n_plots / n_cols)
    
    par(mfrow = c(n_rows, n_cols), mar = c(4, 4, 3, 1))

    # Individual ROCs
    for (miR in input$selectedTargets) {
      df_miR <- df %>% filter(Target == miR)
      if(length(unique(df_miR$Type)) < 2) next
      df_miR$outcome <- ifelse(df_miR$Type == "Tumor", 1, 0)
      roc_obj <- roc(df_miR$outcome, df_miR$fold_change, levels = c(0,1), direction = "<")
      plot(roc_obj, main = miR, col = "blue", lwd = 2)
      legend("bottomright", legend = paste("AUC =", round(auc(roc_obj), 3)), bty = "n")
    }
  })
  
  output$combinedROCPlot <- renderPlot({
    req(input$selectedTargets)
    df <- foldChangeData()
    
    # Prepare data for regularized logistic regression
    df_wide <- df %>%
      filter(Target %in% input$selectedTargets) %>%
      group_by(Sample, Target, Type) %>%
      summarise(fold_change = mean(fold_change, na.rm = TRUE), .groups = "drop") %>%
      pivot_wider(names_from = Target, values_from = fold_change)
    
    if (nrow(df_wide) > 0 && length(unique(df_wide$Type)) == 2) {
      df_wide$outcome <- ifelse(df_wide$Type == "Tumor", 1, 0)
      
      # Clean miRNA names for use in formula
      clean_miRNA_names <- make.names(names(df_wide)[!names(df_wide) %in% c("Sample", "Type", "outcome")])
      names(df_wide)[!names(df_wide) %in% c("Sample", "Type", "outcome")] <- clean_miRNA_names
      
      # Remove rows with any missing values
      df_wide_complete <- df_wide[complete.cases(df_wide), ]
      
      # Check if we still have enough data
      if (nrow(df_wide_complete) < 10) {
        plot(1, type = "n", xlab = "", ylab = "", main = "Not enough complete data for combined ROC")
        text(1, 1, "Need at least 10 complete samples for combined ROC analysis", cex = 0.8)
        return()
      }
      
      if (length(unique(df_wide_complete$outcome)) < 2) {
        plot(1, type = "n", xlab = "", ylab = "", main = "Not enough complete data for combined ROC")
        text(1, 1, "Need both Normal and Tumor samples for ROC analysis", cex = 0.8)
        return()
      }
      
      # Prepare data for glmnet
      X <- as.matrix(df_wide_complete[, clean_miRNA_names])
      y <- df_wide_complete$outcome
      
      # Use cross-validation to find optimal lambda
      cv_fit <- cv.glmnet(X, y, family = "binomial", alpha = 0.5, # Elastic net (mix of L1 and L2)
                         nfolds = input$cvFolds, type.measure = "auc")
      
      # Get predictions using the optimal lambda
      predicted_probs <- predict(cv_fit, newx = X, s = "lambda.min", type = "response")
      
      # Create ROC curve
      combined_roc <- roc(y, as.numeric(predicted_probs))
      
      # Plot ROC curve
      plot(combined_roc, main = "Combined ROC (Regularized Logistic Regression)", col = "red", lwd = 2)
      legend("bottomright", 
             legend = paste("AUC =", round(auc(combined_roc), 3)), 
             bty = "n")
      
      # Add legend with miRNA list
      legend("topright", 
             legend = paste("Included miRNAs:", paste(input$selectedTargets, collapse = ", ")),
             bty = "n", cex = 0.8)
    }
  })
  
  output$modelSummary <- renderPrint({
    req(input$selectedTargets)
    df <- foldChangeData()
    
    # Prepare data for regularized logistic regression
    df_wide <- df %>%
      filter(Target %in% input$selectedTargets) %>%
      group_by(Sample, Target, Type) %>%
      summarise(fold_change = mean(fold_change, na.rm = TRUE), .groups = "drop") %>%
      pivot_wider(names_from = Target, values_from = fold_change)
    
    if (nrow(df_wide) > 0 && length(unique(df_wide$Type)) == 2) {
      df_wide$outcome <- ifelse(df_wide$Type == "Tumor", 1, 0)
      
      # Clean miRNA names for use in formula
      clean_miRNA_names <- make.names(names(df_wide)[!names(df_wide) %in% c("Sample", "Type", "outcome")])
      names(df_wide)[!names(df_wide) %in% c("Sample", "Type", "outcome")] <- clean_miRNA_names
      
      # Remove rows with any missing values
      df_wide_complete <- df_wide[complete.cases(df_wide), ]
      
      # Check if we still have enough data
      if (nrow(df_wide_complete) < 10 || length(unique(df_wide_complete$outcome)) < 2) {
        return("Not enough data for model summary")
      }
      
      # Prepare data for glmnet
      X <- as.matrix(df_wide_complete[, clean_miRNA_names])
      y <- df_wide_complete$outcome
      
      # Use cross-validation to find optimal lambda
      cv_fit <- cv.glmnet(X, y, family = "binomial", alpha = 0.5,
                         nfolds = input$cvFolds, type.measure = "auc")
      
      cat("Regularized Logistic Regression Model Summary\n")
      cat("=============================================\n")
      cat("Optimal lambda:", cv_fit$lambda.min, "\n")
      cat("Number of samples:", nrow(df_wide_complete), "\n")
      cat("Number of Normal samples:", sum(df_wide_complete$outcome == 0), "\n")
      cat("Number of Tumor samples:", sum(df_wide_complete$outcome == 1), "\n")
      cat("Number of miRNAs:", length(clean_miRNA_names), "\n")
      cat("Cross-validation folds:", input$cvFolds, "\n")
    }
  })
}

shinyApp(ui = ui, server = server)
